<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>360 Image Viewer & Editor (v6.2)</title>
  <style>
    /* === Global Layout & UI Styles === */
    html, body { height:100%; margin:0; background:#000; color:#eee; font-family: Inter, Arial, sans-serif; }
    #container { position:relative; width:100%; height:100%; overflow:hidden; touch-action:none; background:#000; display:flex; align-items:center; justify-content:center; }
    canvas { display:block; width:100%; height:100%; cursor: grab; background:#000; }
    .overlay { position:absolute; top:12px; left:12px; padding:10px 12px; background:rgba(0,0,0,0.45); border-radius:8px; font-size:13px; line-height:1.3; color:#fff; backdrop-filter:blur(4px); user-select:none; }
    .controls { position:absolute; right:12px; top:12px; display:flex; gap:8px; }
    button { background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.12); color:#fff; padding:8px 10px; border-radius:8px; cursor:pointer; font-size:13px; }
    button:hover { background:rgba(255,255,255,0.12); }
    #dropHint { position:absolute; left:50%; transform:translateX(-50%); padding:8px 12px; background:rgba(0,0,0,0.45); border-radius:8px; font-size:13px; color:#fff; user-select:none; }
    .drop-active { outline:3px dashed rgba(255,255,255,0.14); outline-offset:-8px; }
    .small { font-size:12px; opacity:0.95; }
    /* === Image Loading Progress Bar === */
    #progressWrapper { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:320px; height:22px; background:rgba(255,255,255,0.08); border-radius:12px; overflow:hidden; display:none; }
    #progressBar { height:100%; width:0%; background:linear-gradient(90deg,#4db8ff,#0077ff); transition:width 0.2s ease; }
    #progressText { position:absolute; top:0; left:0; width:100%; text-align:center; line-height:22px; font-size:12px; color:#fff; text-shadow:0 0 4px rgba(0,0,0,.6); }
    /* === Editing Panel Styles === */
    #editPanel { position:absolute; top:52px; right:12px; background:rgba(0,0,0,0.55); border-radius:8px; padding:12px; backdrop-filter:blur(5px); display:none; flex-direction:column; gap:10px; width:220px; }
    .edit-control { display:grid; grid-template-columns: 60px 1fr 40px; align-items:center; gap:8px; }
    .edit-control label { font-size:13px; }
    .edit-control input[type="range"] { width:100%; margin:0; }
    .edit-control input[type="number"] { width:40px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.15); color:#fff; border-radius:4px; padding:4px; font-size:12px; text-align:center; -moz-appearance: textfield; }
    .edit-control input[type="number"]::-webkit-outer-spin-button, .edit-control input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    #actionButtons { display:flex; gap:8px; margin-top:8px; }
    #actionButtons button { flex:1; }
  </style>
</head>
<body>
  <div id="container">
    <div class="overlay">360 Image Viewer<br/><span class="small">Left click drag: Rotate viewpoint ‚Ä¢ Wheel: Zoom in/out</span></div>
    <div class="controls">
      <button id="openFileBtn">üìÅ Open file</button>
      <button id="editBtn">üé® Image editing</button>
      <button id="fullscreenBtn">üî≥ Full screen</button>
      <button id="resetBtn">‚ü≥ Reset</button>
    </div>
    <div id="dropHint">Drag and drop images here.</div>
    <div id="progressWrapper"><div id="progressBar"></div><div id="progressText">0%</div></div>
    
    <div id="editPanel">
      <div class="edit-control">
        <label for="brightness">Brightness</label>
        <input type="range" id="brightness" min="0" max="2" value="1" step="0.01">
        <input type="number" id="brightnessValue" min="0" max="2" value="1" step="0.01">
      </div>
      <div class="edit-control">
        <label for="saturation">Saturation</label>
        <input type="range" id="saturation" min="0" max="2" value="1" step="0.01">
        <input type="number" id="saturationValue" min="0" max="2" value="1" step="0.01">
      </div>
      <div class="edit-control">
        <label for="contrast">Contrast</label>
        <input type="range" id="contrast" min="0" max="2" value="1" step="0.01">
        <input type="number" id="contrastValue" min="0" max="2" value="1" step="0.01">
      </div>
      <div id="actionButtons">
        <button id="saveJpgBtn">JPG Save</button>
        <button id="resetFiltersBtn">‚ú® Reset</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script>
    /* === DOM Element References === */
    const container = document.getElementById('container');
    const dropHint = document.getElementById('dropHint');
    const openFileBtn = document.getElementById('openFileBtn');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const resetBtn = document.getElementById('resetBtn');
    const progressWrapper = document.getElementById('progressWrapper');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const editBtn = document.getElementById('editBtn');
    const editPanel = document.getElementById('editPanel');
    const brightnessSlider = document.getElementById('brightness');
    const saturationSlider = document.getElementById('saturation');
    const contrastSlider = document.getElementById('contrast');
    const brightnessValue = document.getElementById('brightnessValue');
    const saturationValue = document.getElementById('saturationValue');
    const contrastValue = document.getElementById('contrastValue');
    const saveJpgBtn = document.getElementById('saveJpgBtn');
    // MODIFIED: Reference to the new reset button
    const resetFiltersBtn = document.getElementById('resetFiltersBtn');

    /* === Three.js Fields === */
    let scene, camera, renderer, sphereMesh, originalTexture;
    let editCanvas, editContext;

    /* === User Input State === */
    let isUserInteracting = false;
    let onPointerDownPointerX = 0, onPointerDownPointerY = 0;
    let lon = 0, lat = 0;
    let onPointerDownLon = 0, onPointerDownLat = 0;

    init();
    animate();

    function init(){
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, container.clientWidth/container.clientHeight, 1, 1100);
      camera.target = new THREE.Vector3(0,0,1);

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance', preserveDrawingBuffer: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      container.appendChild(renderer.domElement);

      const geometry = new THREE.SphereGeometry(500, 64, 40);
      const material = new THREE.MeshBasicMaterial({ color:0xffffff, side:THREE.BackSide });
      sphereMesh = new THREE.Mesh(geometry, material);
      scene.add(sphereMesh);

      renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
      renderer.domElement.addEventListener('mousedown', onPointerDown);
      document.addEventListener('mousemove', onPointerMove);
      document.addEventListener('mouseup', onPointerUp);
      renderer.domElement.addEventListener('wheel', onDocumentMouseWheel, { passive:false });

      renderer.domElement.addEventListener('touchstart', onTouchStart, { passive:false });
      renderer.domElement.addEventListener('touchmove', onTouchMove, { passive:false });
      renderer.domElement.addEventListener('touchend', onPointerUp);

      ['dragenter','dragover'].forEach(evt=>container.addEventListener(evt, e=>{e.preventDefault(); container.classList.add('drop-active');}));
      ['dragleave','drop'].forEach(evt=>container.addEventListener(evt, e=>{e.preventDefault(); container.classList.remove('drop-active');}));
      container.addEventListener('drop', onDrop);

      openFileBtn.addEventListener('click', ()=>{
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.jpg,.jpeg,image/jpeg,image/jpg';
        input.onchange = e => { const f = e.target.files[0]; if(f) loadImageFile(f); };
        input.click();
      });
      fullscreenBtn.addEventListener('click', ()=>{
        if(!document.fullscreenElement){ container.requestFullscreen?.(); } else { document.exitFullscreen?.(); }
      });
      resetBtn.addEventListener('click', resetView);

      editBtn.addEventListener('click', toggleEditPanel);
      brightnessSlider.addEventListener('input', updateImageFilters);
      saturationSlider.addEventListener('input', updateImageFilters);
      contrastSlider.addEventListener('input', updateImageFilters);
      brightnessValue.addEventListener('input', ()=>syncSlider('brightness'));
      saturationValue.addEventListener('input', ()=>syncSlider('saturation'));
      contrastValue.addEventListener('input', ()=>syncSlider('contrast'));
      saveJpgBtn.addEventListener('click', ()=>saveImage('jpeg'));
      
      // MODIFIED: Event listener for the new reset button
      resetFiltersBtn.addEventListener('click', ()=>{
        resetEditControls();
        updateImageFilters(); // Apply the reset values to the image
      });

      window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize(){
      camera.aspect = container.clientWidth/container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function onPointerDown(event){
      if(event.button !== 0) return;
      isUserInteracting = true;
      renderer.domElement.style.cursor = 'grabbing';
      onPointerDownPointerX = event.clientX;
      onPointerDownPointerY = event.clientY;
      onPointerDownLon = lon;
      onPointerDownLat = lat;
    }
    function onPointerMove(event){
      if(isUserInteracting){
        const dx = event.clientX - onPointerDownPointerX;
        const dy = event.clientY - onPointerDownPointerY;
        lon = onPointerDownLon - dx * 0.1;
        lat = onPointerDownLat + dy * 0.1;
        lat = Math.max(-85, Math.min(85, lat));
      }
    }
    function onPointerUp(){ isUserInteracting=false; renderer.domElement.style.cursor='grab'; }
    function onDocumentMouseWheel(event){
      event.preventDefault();
      camera.fov = THREE.MathUtils.clamp(camera.fov + event.deltaY * 0.03, 30, 100);
      camera.updateProjectionMatrix();
    }

    let touchX, touchY, touchStartLon, touchStartLat;
    function onTouchStart(event){
      if(event.touches.length === 1){
        event.preventDefault();
        touchX = event.touches[0].pageX; touchY = event.touches[0].pageY;
        touchStartLon = lon; touchStartLat = lat;
      }
    }
    function onTouchMove(event){
      if(event.touches.length === 1){
        event.preventDefault();
        const dx = event.touches[0].pageX - touchX;
        const dy = event.touches[0].pageY - touchY;
        lon = touchStartLon - dx * 0.1;
        lat = touchStartLat + dy * 0.1;
        lat = Math.max(-85, Math.min(85, lat));
      }
    }

    function onDrop(event){ const file = event.dataTransfer.files[0]; if(file) loadImageFile(file); }

    function loadImageFile(file){
      const valid = /(jpe?g)$/i.test(file.name) || file.type.startsWith('image/');
      if(!valid){ alert('Only JPG/JPEG image files are supported.'); return; }

      progressWrapper.style.display='block';
      progressBar.style.width='0%';
      progressText.textContent='0%';

      const reader = new FileReader();
      reader.onprogress = (e)=>{
        if(e.lengthComputable){
          const p = Math.round((e.loaded / e.total) * 100);
          progressBar.style.width = p + '%';
          progressText.textContent = p + '%';
        }
      };
      reader.onload = ()=>{
        const loader = new THREE.TextureLoader();
        loader.load(
          reader.result,
          (texture)=>{
            originalTexture = texture;
            originalTexture.colorSpace = THREE.SRGBColorSpace;
            originalTexture.minFilter = THREE.LinearFilter;
            originalTexture.magFilter = THREE.LinearFilter;
            originalTexture.wrapS = THREE.RepeatWrapping;
            originalTexture.repeat.x = -1;
            originalTexture.offset.x = 1;
            
            editCanvas = document.createElement('canvas');
            editContext = editCanvas.getContext('2d');
            editCanvas.width = originalTexture.image.width;
            editCanvas.height = originalTexture.image.height;

            resetEditControls();
            applyTexture(originalTexture);

            dropHint.textContent = file.name;
            progressBar.style.width = '100%';
            progressText.textContent = '100%';
            setTimeout(()=> progressWrapper.style.display='none', 500);
          },
          undefined,
          (err)=>{
            console.error('Texture load error', err);
            alert('Failed to load image');
            progressWrapper.style.display='none';
          }
        );
      };
      reader.onerror = ()=>{
        alert('Failed to read file');
        progressWrapper.style.display='none';
      };
      reader.readAsDataURL(file);
    }

    function animate(){ requestAnimationFrame(animate); update(); renderer.render(scene, camera); }

    function update(){
      const phi = THREE.MathUtils.degToRad(90 - lat);
      const theta = THREE.MathUtils.degToRad(lon);
      const x = Math.sin(phi) * Math.cos(theta);
      const y = Math.cos(phi);
      const z = Math.sin(phi) * Math.sin(theta);
      camera.lookAt(new THREE.Vector3(x,y,z));
    }

    function resetView(){
      lon=0; lat=0; camera.fov=75; camera.updateProjectionMatrix();
      if(originalTexture) {
        resetEditControls();
        updateImageFilters();
      }
    }
    
    function toggleEditPanel() {
      if (!originalTexture) {
        alert('First, please load the image.');
        return;
      }
      const isVisible = editPanel.style.display === 'flex';
      editPanel.style.display = isVisible ? 'none' : 'flex';
    }

    function updateImageFilters() {
      if (!originalTexture || !editContext) return;

      const brightness = parseFloat(brightnessSlider.value);
      const saturation = parseFloat(saturationSlider.value);
      const contrast = parseFloat(contrastSlider.value);
      
      brightnessValue.value = brightness.toFixed(2);
      saturationValue.value = saturation.toFixed(2);
      contrastValue.value = contrast.toFixed(2);
      
      editContext.filter = `brightness(${brightness}) saturate(${saturation}) contrast(${contrast})`;
      editContext.drawImage(originalTexture.image, 0, 0);

      const editedTexture = new THREE.CanvasTexture(editCanvas);
      editedTexture.colorSpace = THREE.SRGBColorSpace;
      editedTexture.minFilter = THREE.LinearFilter;
      editedTexture.magFilter = THREE.LinearFilter;
      editedTexture.wrapS = THREE.RepeatWrapping;
      editedTexture.repeat.x = -1;
      editedTexture.offset.x = 1;

      applyTexture(editedTexture);
    }
    
    function syncSlider(type) {
        const valueInput = document.getElementById(type + 'Value');
        const slider = document.getElementById(type);
        let value = parseFloat(valueInput.value);
        if (isNaN(value)) return;
        
        const min = parseFloat(slider.min);
        const max = parseFloat(slider.max);
        value = Math.max(min, Math.min(max, value));
        valueInput.value = value;
        slider.value = value;
        
        updateImageFilters();
    }

    function applyTexture(newTexture) {
      if (sphereMesh.material.map && sphereMesh.material.map !== originalTexture) {
        sphereMesh.material.map.dispose();
      }
      sphereMesh.material.map = newTexture;
      sphereMesh.material.needsUpdate = true;
    }
    
    function resetEditControls() {
        brightnessSlider.value = 1;
        saturationSlider.value = 1;
        contrastSlider.value = 1;
        brightnessValue.value = '1.00';
        saturationValue.value = '1.00';
        contrastValue.value = '1.00';
    }

    function saveImage(format) {
      if (!sphereMesh.material.map) {
        alert('There are no images to save.');
        return;
      }
      const dataURL = renderer.domElement.toDataURL(`image/${format}`);
      const link = document.createElement('a');
      link.href = dataURL;
      link.download = `panorama_view_${Date.now()}.${format}`;
      link.click();
    }
  </script>
</body>
</html>